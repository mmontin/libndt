
@PhdThesis{thesis_bayley,
  author = {Ian Bayley},
  title  = {Generic Operations on Nested Datatypes},
  year   = {2001},
  school = {University of Oxford},
}

@Article{hinze_paterson_2006,
  author    = {HINZE, RALF and PATERSON, ROSS},
  title     = {Finger trees: a simple general-purpose data structure},
  journal   = {Journal of Functional Programming},
  year      = {2006},
  volume    = {16},
  number    = {2},
  pages     = {197–217},
  doi       = {10.1017/S0956796805005769},
  publisher = {Cambridge University Press},
}

@InProceedings{bird_meertens_nested,
  author    = {Bird, Richard and Meertens, Lambert},
  title     = {Nested datatypes},
  booktitle = {Mathematics of Program Construction},
  year      = {1998},
  editor    = {Jeuring, Johan},
  publisher = {Springer Berlin Heidelberg},
  isbn      = {978-3-540-69345-1},
  pages     = {52--67},
  abstract  = {A nested datatype, also known as a non-regular datatype, is a parametrised datatype whose declaration involves different instances of the accompanying type parameters. Nested datatypes have been mostly ignored in functional programming until recently, but they are turning out to be both theoretically important and useful in practice. The aim of this paper is to suggest a functorial semantics for such datatypes, with an associated calculational theory that mirrors and extends the standard theory for regular datatypes. Though elegant and generic, the proposed approach appears more limited than one would like, and some of the limitations are discussed.},
  address   = {Berlin, Heidelberg},
}

@Article{Fu2018,
  author        = {Peng Fu and Peter Selinger},
  title         = {Dependently Typed Folds for Nested Data Types},
  __markedentry = {[camel:6]},
  abstract      = {We present an approach to develop folds for nested data types using dependent types. We call such folds $\textit{dependently typed folds}$, they have the following properties. (1) Dependently typed folds are defined by well-founded recursion and they can be defined in a total dependently typed language. (2) Dependently typed folds do not depend on maps, map functions and many terminating functions can be defined using dependently typed folds. (3) The induction principles for nested data types follow from the definitions of dependently typed folds and the programs defined by dependently typed folds can be formally verified. (4) Dependently typed folds exist for any nested data types and they can be specialized to the traditional $\textit{higher-order folds}$. Using various of examples, we show how to program and reason about dependently typed folds. We also show how to obtain dependently typed folds in general and how to specialize them to the corresponding higher-order folds.},
  date          = {2018-06-13},
  eprint        = {1806.05230v1},
  eprintclass   = {cs.LO},
  eprinttype    = {arXiv},
  file          = {online:http\://arxiv.org/pdf/1806.05230v1:PDF},
  keywords      = {cs.LO, cs.PL},
}

@Article{Johann2021,
  author        = {Patricia Johann and Enrico Ghiorzi and Daniel Jeffries},
  title         = {Parametricity for Nested Types and GADTs},
  __markedentry = {[camel:6]},
  abstract      = {This paper considers parametricity and its consequent free theorems for nested data types. Rather than representing nested types via their Church encodings in a higher-kinded or dependently typed extension of System F, we adopt a functional programming perspective and design a Hindley-Milner-style calculus with primitives for constructing nested types directly as fixpoints. Our calculus can express all nested types appearing in the literature, including truly nested types. At the level of terms, it supports primitive pattern matching, map functions, and fold combinators for nested types. Our main contribution is the construction of a parametric model for our calculus. This is both delicate and challenging. In particular, to ensure the existence of semantic fixpoints interpreting nested types, and thus to establish a suitable Identity Extension Lemma for our calculus, our type system must explicitly track functoriality of types, and cocontinuity conditions on the functors interpreting them must be appropriately threaded throughout the model construction. We also prove that our model satisfies an appropriate Abstraction Theorem, as well as that it verifies all standard consequences of parametricity in the presence of primitive nested types. We give several concrete examples illustrating how our model can be used to derive useful free theorems, including a short cut fusion transformation, for programs over nested types. Finally, we consider generalizing our results to GADTs, and argue that no extension of our parametric model for nested types can give a functorial interpretation of GADTs in terms of left Kan extensions and still be parametric.},
  date          = {2021-01-13},
  eprint        = {2101.04819v1},
  eprintclass   = {cs.LO},
  eprinttype    = {arXiv},
  file          = {online:http\://arxiv.org/pdf/2101.04819v1:PDF},
  keywords      = {cs.LO},
}

@Article{Johann2021a,
  author        = {Patricia Johann and Enrico Ghiorzi and Daniel Jeffries},
  title         = {(Deep) Induction Rules for GADTs},
  __markedentry = {[camel:6]},
  abstract      = {Deep data types are those that are defined in terms of other such data types, including, possibly, themselves. In that case, they are said to be truly nested. Deep induction is an extension of structural induction that traverses all of the structure in a deep data type, propagating predicates on its primitive data throughout the entire structure. Deep induction can be used to prove properties of nested types, including truly nested types, that cannot be proved via structural induction. In this paper we show how to extend deep induction to deep GADTs that are not truly nested. We also show that deep induction cannot be extended to truly nested GADTs.},
  date          = {2021-05-17},
  eprint        = {2105.08155v1},
  eprintclass   = {cs.LO},
  eprinttype    = {arXiv},
  file          = {online:http\://arxiv.org/pdf/2105.08155v1:PDF},
  keywords      = {cs.LO},
}

@InProceedings{th_for_free,
  author    = {Wadler, Philip},
  title     = {Theorems for Free!},
  booktitle = {Proceedings of the Fourth International Conference on Functional Programming Languages and Computer Architecture},
  year      = {1989},
  series    = {FPCA '89},
  publisher = {Association for Computing Machinery},
  location  = {Imperial College, London, United Kingdom},
  isbn      = {0897913280},
  pages     = {347–359},
  doi       = {10.1145/99370.99404},
  url       = {https://doi.org/10.1145/99370.99404},
  address   = {New York, NY, USA},
  numpages  = {13},
}

@Comment{jabref-meta: databaseType:biblatex;}
